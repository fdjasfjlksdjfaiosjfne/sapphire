"""Meta-programming go brrrrrrrrrrrrrrrrrrrrr"""

import asyncio
import itertools
import pathlib
import sys
import typing
sys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent.parent))

from backend import errors
from parser._lexer.data.aliases import get_all_itt_used

async def write_subclass(name: str, ls: typing.Iterable[dict | str], indent = 4) -> list[str]:
    if not ls:
        return []
    pad = " " * indent
    lines: list[str] = [
        f"\n{pad}class {name}(ITTTypeChecking):"
    ]
    for i in ls:
        lines.append(f"{pad}    {i} = enum.auto()")
    return lines

async def write_template_class(dct: dict[str, list[str]]) -> list[str]:
    if not any(dct.values()):
        return []
    lines = [
        f"\n    class Templates(ITTTypeChecking):"
    ]

    tasks: list[asyncio.Task] = []
    for template_name, v in dct.items():
        tasks.append(asyncio.create_task(write_subclass(template_name, v, 8)))
    lists = await asyncio.gather(*tasks)
    for list_ in lists:
        lines += list_
    return lines

def organize(ls: typing.Iterable[tuple[str, ...]]) -> tuple[list[str], list[str],
                                                            list[str], list[str],
                                                            list[str], dict[str, list[str]]]:
    uncategorized: list[str] = []
    keywords: list[str] = []
    symbols: list[str] = []
    parens: list[str] = []
    primitives: list[str] = []
    template_dict: dict[str, list[str]] = {}

    for tple in ls:
        match tple:
            case (name,):
                if name not in uncategorized:
                    uncategorized.append(name)
            case ("Keywords", name):
                if name not in keywords:
                    keywords.append(name)
            case ("Symbols", name):
                if name not in symbols:
                    symbols.append(name)
            case ("Primitives", name):
                if name not in primitives:
                    primitives.append(name)
            case ("Parentheses", name):
                if name not in parens:
                    parens.append(name)
            case ("Templates", config_name, name):
                if config_name not in template_dict:
                    template_dict[config_name] = [name]
                if name not in template_dict[config_name]:
                    template_dict[config_name].append(name)
            case tple:
                raise errors.InternalError(
                    f"weeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee- {tple} -ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh"
                )
    return uncategorized, symbols, keywords, parens, primitives, template_dict

async def write_class() -> list[str]:
    lines: list[str] = [
        "\nclass InternalTokenType(ITTTypeChecking):"
    ]
    (uncategorized, symbols, keywords, 
     parentheses, primitives, template_dict) = organize(get_all_itt_used())
    tasks = [
        asyncio.create_task(write_subclass("Parentheses", parentheses)),
        asyncio.create_task(write_subclass("Symbols", symbols)),
        asyncio.create_task(write_subclass("Keywords", keywords)),
        asyncio.create_task(write_subclass("Primitives", primitives)),
        asyncio.create_task(write_template_class(template_dict))
    ]

    results = asyncio.gather(*tasks)

    for i in set(uncategorized) | {"EoF", "_SkipPattern"}:
        lines.append(f"    {i} = enum.auto()")
    
    await results

    for arr in results.result():
        lines.extend(arr)

    return lines

def write_file():
    lines = [
        "# Should be Inteliisense-friendly",
        "# Generated by a bot",
        "# Beep bop",
        "import itertools",
        "import enum",
        "",
        "_global_counter = itertools.count()",
        "",
        "class ITTTypeChecking(enum.Enum):",
        "    @staticmethod",
        "    def _generate_next_value_(name, start, count, last_values):",
        "        return next(_global_counter)"
    ]

    with open(pathlib.Path(__file__).parent.parent / "internal_token_types.py", "w", encoding = "utf-8") as f:
        lines += asyncio.run(write_class())
        f.write("\n".join(lines))

if __name__ == "__main__":
    write_file()